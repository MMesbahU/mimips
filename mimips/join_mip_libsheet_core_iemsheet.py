from __future__ import print_function
from future import standard_library
standard_library.install_aliases()
from builtins import range
#! /usr/bin/env python

import sys

import os
import os.path as op
import argparse
from collections import defaultdict, OrderedDict

from io import StringIO

import re
import glob

import pandas as pd


"""

Join sample sheet generated by our google docs sample tracker with the IEM sample sheets that are 
provided by the core. Check that all fastq files are in place. 

Output a merged sample sheet suitable for input to the mimips pipeline. 

eg IEM sheet
     19 Lane,Sample_ID,Sample_Name,Sample_Plate,Sample_Well,I7_Index_ID,index,index2,Sample_Project,Description
     20 3,Sample_58342,58342_GTGTGCTACA-CCGCATTGGC,,,,GTGTGCTACA,CCGCATTGGC,kitzman,MIO25_A1_CHIPplate3_A1
     21 3,Sample_58343,58343_CGCCTTAAGA-CCATCGTGAT,,,,CGCCTTAAGA,CCATCGTGAT,kitzman,MIO25_B1_CHIPplate3_B1

eg lib key
      1 well    source_plate    source_well     p7_barc_and_well        p5_barc_and_well        p7_barc p5_barc p7_barc_seq     p5_barc_seq     captureset      libname
      2 A1      CHIPplate1      A1      A1:jkP7barc_0096        A1:jkP5barc_0112        jkP7barc_0096   jkP5barc_0112   GTGTGCTACA      GCCGTAGGAG      MIO17   MIO17_A1_CHIPplate1_A1
      3 B1      CHIPplate1      B1      B1:jkP7barc_0097        B1:jkP5barc_0113        jkP7barc_0097   jkP5barc_0113   CGCCTTAAGA      CTAACCTCCG      MIO17   MIO17_B1_CHIPplate1_B1

we'll join on index,index2 <---> p7_barc_seq,p5_barc_seq
"""



def main():
    
    opts = argparse.ArgumentParser()
   
    opts.add_argument('--libKeyIn', dest='libKeyIn')
    opts.add_argument('--coreIEMSheet', dest='coreIEMSheet')

    opts.add_argument('--libKeyOut', dest='libKeyOut')

    opts.add_argument('--baseDir', dest='baseDir',
        help='base directory for samples')

    opts.add_argument('--restrictToLanes', default=None, dest='restrictToLanes',
        help='restrict to specific lanes in the sample key')

    opts.add_argument('--omitIndexReads', default=False, action='store_true', dest='omitIndexReads',
        help='don\'t look for index reads')
    
    o = opts.parse_args()

    lkIn = pd.read_csv(o.libKeyIn,sep='\t' )

    llinesCoreIem=[ l.rstrip() for l in open(o.coreIEMSheet,'r') ]
    ilineDataHdr=[ i for i in range(len(llinesCoreIem)) if llinesCoreIem[i].startswith('[Data]')  ]

    lLanes = None if o.restrictToLanes is None \
             else [int(x) for x in o.restrictToLanes.split(',')]

    # scrape a flowcell name
    runName = llinesCoreIem[
        [ i for i in range(len(llinesCoreIem)) if llinesCoreIem[i].startswith('Description')  ][0]
        ].split(',')[1]

    # dump the bottom part of this file into pandas.
    asstrCoreIEM=StringIO( ('\n'.join(llinesCoreIem[ilineDataHdr[0]+1:])).decode('utf-8') )
    coreIemIn = pd.read_csv( asstrCoreIEM,sep=',' )

    if lLanes is not None:
        coreIemIn = coreIemIn.loc[ [ i for i,r in coreIemIn.iterrows() if r['Lane'] in lLanes ] ].copy()

    coreIemIn[ 'pairindexseq' ] = [ '%s-%s'%(r['index'],r['index2']) for _,r in coreIemIn.iterrows() ]
    coreIemIn = coreIemIn.set_index( 'pairindexseq' )

    lkIn[ 'pairindexseq' ] = [ '%s-%s'%(r['p7_barc_seq'],r['p5_barc_seq']) for _,r in lkIn.iterrows() ]

    assert all( lkIn.pairindexseq.isin(coreIemIn.index) ), '%s not in IEM sheet: '%(','.join([ pix for pix in lkIn.pairindexseq if pix not in coreIemIn.index]))

    for c in ['lane','core_sampleid','core_sampleidnum','fq_fwd']+(['fqi1','fqi2'] if not o.omitIndexReads else [])+['fq_rev']:
        lkIn[c]=''

    lkIn['flowcell']=runName.replace('_','')

    # we need to make sure that all (pairindexseq,lane) combinations are in lkIn
    # it may only have each lib listed once while the lib may actually be repeated across lanes
    lkInNew = []
    for i,r in lkIn.iterrows():
        liemline = pd.DataFrame( coreIemIn.loc[ r['pairindexseq'] ] )
        for _,iemline in liemline.iterrows():
            lkInNew.append(r.copy())
            lkInNew[-1]['lane']=iemline['Lane']  
    lkIn = pd.DataFrame( lkInNew ).reset_index()


    liDel=[]

    for i,r in lkIn.iterrows():

        # can be multiple rows with this index combination, split across multiple lanes
        iemline = coreIemIn.loc[ r['pairindexseq'] ].query( 'Lane==%d'%r['lane'] )

        assert iemline.shape[0]==1

        iemline = iemline.iloc[0]

        sampleid = iemline['Sample_ID']
        matchSid = re.match( 'Sample_(?P<sampnum>\d+)', sampleid ).groupdict()
        sampleidnumpart = matchSid[ 'sampnum' ]

        sampDir = op.join(o.baseDir, sampleid )

        lFiles = [ op.split(x)[1] for x in glob.glob( '%s/*.fastq.gz'%sampDir ) ]

        if len(lFiles)==0:
            print('warning: no files found under %s'%sampDir)
            print('row is ', r)
            liDel+=[i]
            continue

        pat='%s_%s_S\d+_L%03d_R1_001.fastq.gz'%( sampleidnumpart, r['pairindexseq'], iemline['Lane'] )
        fnmatches = [ re.match( pat,fn ) for fn in lFiles ]
        assert len( [m for m in fnmatches if m] )==1,'!=1 matching %s'%pat
        lkIn.ix[i, 'fq_fwd'] = op.join( sampDir, [m for m in fnmatches if m][0].group(0) )

        pat='%s_%s_S\d+_L%03d_R2_001.fastq.gz'%( sampleidnumpart, r['pairindexseq'], iemline['Lane'] )
        fnmatches = [ re.match( pat,fn ) for fn in lFiles ]
        assert len( [m for m in fnmatches if m] )==1,'!=1 matching %s'%pat
        lkIn.ix[i, 'fq_rev'] = op.join( sampDir, [m for m in fnmatches if m][0].group(0) )

        if not o.omitIndexReads:
            pat='%s_%s_S\d+_L%03d_I1_001.fastq.gz'%( sampleidnumpart, r['pairindexseq'], iemline['Lane'] )
            fnmatches = [ re.match( pat,fn ) for fn in lFiles ]
            assert len( [m for m in fnmatches if m] )==1,'!=1 matching %s'%pat
            lkIn.ix[i, 'fqi1'] = op.join( sampDir, [m for m in fnmatches if m][0].group(0) )

            pat='%s_%s_S\d+_L%03d_I2_001.fastq.gz'%( sampleidnumpart, r['pairindexseq'], iemline['Lane'] )
            fnmatches = [ re.match( pat,fn ) for fn in lFiles ]
            assert len( [m for m in fnmatches if m] )==1,'!=1 matching %s'%pat
            lkIn.ix[i, 'fqi2'] = op.join( sampDir, [m for m in fnmatches if m][0].group(0) )

        lkIn.ix[i, 'lane'] = iemline['Lane']
        lkIn.ix[i, 'core_sampleid'] = sampleid
        lkIn.ix[i, 'core_sampleidnum'] = sampleidnumpart

    lkIn = lkIn.ix[ ~lkIn.index.isin(liDel) ]

    lkIn.to_csv( o.libKeyOut, sep='\t', index=False )


if __name__ == '__main__':
    main()

